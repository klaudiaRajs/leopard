<?php


class tokenizer
{
	/** @var token[] */
	private $tokens;

	public function __construct($fileContents)
	{
		$unifiedContents = str_replace("\r", '', $fileContents);
		$this->parse($unifiedContents);
	}

	public function getAll()
	{
		return $this->tokens;
	}

	private function parse($fileContents)
	{
		$additional = [
			';' => token::SEMICOLON,
			'"' => token::DOUBLE_QUOTE,
			'[' => token::SQUARE_BRACKET_OPEN,
			']' => token::SQUARE_BRACKET_CLOSE,
			'{' => token::CURLY_BRACKET_OPEN,
			'}' => token::CURLY_BRACKET_CLOSE,
			'(' => token::BRACKET_OPEN,
			')' => token::BRACKET_CLOSE,
			'=' => token::ASSIGNMENT,
			'!' => token::EXCLAMATION_MARK,
			'.' => token::DOT,
			',' => token::COMMA,
			'?' => token::QUESTION_MARK,
			':' => token::COLON,
		];
		$tokens = token_get_all($fileContents);
		$lastLine = 1;
		foreach ($tokens as $token) {
			if (is_array($token)) {
				$this->tokens[] = new token($token[0], $token[1], $token[2], token_name($token[0]), null, null);
				$lastLine = $token[2];
			} elseif (isset($additional[$token])) {
				if (strpos($token, "\n")) {
					print_r($token);
					exit;
				}
				$this->tokens[] = new token($additional[$token], $token, $lastLine, $additional[$token], null, null);
			} else {
				print_r($token);
				exit;
			}
		}
	}

	public function getTokenMessages($tokens)
	{
		foreach ($tokens as $key => $token) {
			$tokens[$key]->tokenMessage = $this->containsStatics($token);
			$tokens[$key]->tokenMessage .= $this->containsDeprecated($token);
			$tokens[$key]->tokenMessage .= $this->containsGlobal($token);
			$tokens[$key]->tokenMessage .= $this->containsUnusedVariables($key, $token, $tokens);
		}

		//@TODO check what is appropriate length of a structure
		$tokens = $this->isTooLongStructure($tokens, 'T_FUNCTION', 10);
		$tokens = $this->isTooLongStructure($tokens, 'T_CLASS', 30);
		$tokens = $this->areLinesTooLong($tokens, 120);
		$tokens = $this->findUnusedMethods($tokens);
		//@TODO check correct number of params
		$tokens = $this->hasFunctionTooManyParameters($tokens, 5);
		return $tokens;
	}

	private function containsDeprecated($token)
	{
		$message = null;
		if ($token->tokenName == 'T_STRING') {
			foreach (rules_helper::deprecated() as $function => $solution) {
				if ($token->content == $function) {
					if ($solution) {
						$message = "This method is deprecated. Suggested: " . $solution;
					} else {
						$message = "This method is deprecated. ";
					}
				}
			}
		}
		return $message;
	}

	private function containsGlobal($token)
	{
		if ($token->tokenName == 'T_VARIABLE' && in_array($token->content, rules_helper::globals())) {
			return "Shouldn't use global variables";
		}
		return null;
	}

	private function containsStatics($token)
	{
		if ($token->tokenName == 'T_STATIC') {
			return "Shouldn't use statics if it's not absolutely necessary";
		}
		return null;
	}

	private function containsUnusedVariables($key, $token_, $tokens)
	{
		$message = null;
		if ($token_->tokenName == "T_VARIABLE" && $this->containsGlobal($token_) == null) {
			$variable = $token_->content;
			foreach ($tokens as $tokenKey => $token) {
				$message = "This is unused variables. ";
				if ($token->tokenName == "T_VARIABLE" && $token->content == $variable && $tokenKey !== $key) {
					$message = null;
					break;
				}
			}
		}
		return $message;
	}

	private function isTooLongStructure($tokens, string $type, int $length)
	{
		$startOfFunction = [];
		$curlyBracketOpen = 0;
		$curlyBracketClose = 0;
		$counter = 0;
		for ($i = 0; $i < count($tokens); $i++) {
			if ($tokens[$i]->tokenName == $type) {
				$startOfFunction[$counter]['start'] = $tokens[$i]->lineNumber + 1;
				$startOfFunction[$counter]['i'] = $i;

				for ($j = $i; $j < count($tokens); $j++) {
					if ($tokens[$j]->tokenName == token::CURLY_BRACKET_OPEN) {
						$curlyBracketOpen++;
					}
					if ($tokens[$j]->tokenName == token::CURLY_BRACKET_CLOSE) {
						$curlyBracketClose++;
					}
					if ($curlyBracketOpen > 0 && $curlyBracketOpen == $curlyBracketClose) {
						$startOfFunction[$counter]['end'] = $tokens[$j]->lineNumber;
						break;
					}
				}
				$counter++;
			}
			$curlyBracketOpen = 0;
			$curlyBracketClose = 0;
		}

		foreach ($startOfFunction as $data) {
			if ($data['end'] - $data['start'] > $length) {
				$tokens[$data['i']]->tokenMessage .= " This structure is too long. ";
			}
		}
		return $tokens;
	}

	private function areLinesTooLong($tokens, $maxLineLength)
	{
		$tokensForLine = [];
		foreach ($tokens as $key => $token) {
			$token->tokenKey = $key;
			if ($token->tokenIdx == T_WHITESPACE && preg_match('/[\n]+/', $token->content)) {
				if (!empty($tokensForLine)) {
					if ($this->isLineToLong($tokensForLine, $maxLineLength)) {
						foreach ($tokensForLine as $token_) {
							$tokens[$token_->tokenKey]->tokenMessage .= "This line is too long. ";
						}
					}
					$tokensForLine = [];
				}

				//show additional empty lines
				$lines = explode("\n", $token->content);
				foreach ($lines as $index => $line) {
					//one line is added by default by getFormattedLine
					if ($index == 0) {
						continue;
					}
					//if last line is empty we skip it, if it has spaces/tabs we add the
					if ($index == count($lines) - 1 && empty($line)) {
						continue;
					}

					if (!empty($line)) {
						$tokensForLine[] = new TokenView(T_WHITESPACE, $line, token_name(T_WHITESPACE), $token->tokenMessage, $token->tokenKey);
					}
				}
				continue;
			}

			//it is complex token with a new line
			if (strpos($token->content, "\n") !== false) {
				$lines = explode("\n", $token->content);
				foreach ($lines as $lineNumber => $lineContent) {
					if (empty($lineContent)) {
						continue;
					}
					//if this is first iteration there may be already something for this line so we just include the next token
					$tokensForLine[] = new TokenView($token->tokenIdx, $lineContent, $token->tokenName, $token->tokenMessage, $token->tokenKey);
					if (strlen(strip_tags($lineContent)) > $maxLineLength) {
						$tokens[$key]->tokenMessage .= "This structure contains too long of a line. ";
					}
					$tokensForLine = [];
				}
				continue;
			}

			$tokensForLine[] = TokenView::fromToken($token);
		}
		return $tokens;
	}

	private function isLineToLong($tokensForLine, $maxLineLength)
	{
		$lineLength = 0;
		foreach ($tokensForLine as $token) {
			$lineLength += strlen($token->content);
		}

		if ($lineLength < $maxLineLength) {
			return false;
		}
		return true;
	}

	private function findUnusedMethods($tokens)
	{
		for ($i = 0; $i < count($tokens); $i++) {
			if ($tokens[$i]->tokenName == 'T_FUNCTION') {
				$functionNameFound = false;
				for ($j = $i + 1; $j < count($tokens); $j++) {
					if ($tokens[$j]->tokenName == 'T_STRING') {
						for ($h = $j + 1; $h < count($tokens); $h++) {
							if ($tokens[$h]->tokenName == 'bracketOpen') {
								$tokens[$j]->tokenMessage .= $this->checkIfFunctionUsed($tokens[$j]->content, $tokens, $j);
								$functionNameFound = true;
								break;
							}
						}
						if ($functionNameFound) {
							break;
						}
					}
					if ($functionNameFound) {
						break;
					}
				}
			}
		}
		return $tokens;
	}

	private function checkIfFunctionUsed($content, $tokens, $k)
	{
		foreach ($tokens as $key => $token) {
			if ($token->content == $content && $k !== $key) {
				$whitespaceCounter = $key + 1;
				while ($tokens[$whitespaceCounter]->tokenName == 'T_WHITESPACE') {
					$whitespaceCounter++;
				}
				if ($tokens[$whitespaceCounter]->tokenName == 'bracketOpen') {
					return null;
				}
			}
		}
		return "This method seems not to be used. ";
	}

	private function hasFunctionTooManyParameters($tokens, $maxNumberOfParams)
	{
		for ($i = 0; $i < count($tokens); $i++) {
			if ($tokens[$i]->tokenName == 'T_FUNCTION') {
				$functionNameFound = false;
				for ($j = $i + 1; $j < count($tokens); $j++) {
					if ($tokens[$j]->tokenName == 'T_STRING') {
						for ($h = $j + 1; $h < count($tokens); $h++) {
							if ($tokens[$h]->tokenName == 'bracketOpen') {
								$tokens[$j]->tokenMessage .= $this->checkIfFunctionUsed($tokens[$j]->content, $tokens, $j);
								$functionNameFound = true;
								for ($k = $h + 1; $k < count($tokens); $k++) {
									if ($tokens[$k]->tokenName == 'bracketClose') {
										$this->countParams($tokens, $h + 1, $k);
										break;
									}
								}
								break;
							}
						}
						if ($functionNameFound) {
							break;
						}
					}
					if ($functionNameFound) {
						break;
					}
				}
			}
		}
		return $tokens;
	}

	//Implementation of suffix tree - code repetiton detection
	public static function longestRepeatedSubstring($str)
	{
		if ($str == null)
			return null;

		$N = strlen($str);
		$substrings = array();

		for ($i = 0; $i < $N; $i++) {
			$substrings[$i] = substr($str, $i);
		}

		sort($substrings);

		$result = "";
		$results = [];

		for ($i = 0; $i < $N - 1; $i++) {
			$longestCommonString = self::longestCommonString($substrings[$i], $substrings[$i + 1]);

			if (strlen($longestCommonString) > strlen($result)) {
				$result = $longestCommonString;
				echo "";
			}
		}

		return $result;
	}

	private static function longestCommonString($a, $b)
	{
		$n = min(strlen($a), strlen($b));
		$result = "";

		for ($i = 0; $i < $n; $i++) {
			if ($a[$i] == $b[$i])
				$result .= $a[$i];
			else
				break;
		}

		return $result;
	}

	private function countParams($tokens, $h, $k)
	{
		$params = 0;
		for ($i = $h; $i <= $k; $i++) {
			if ($tokens[$i]->tokenName == 'T_VARIABLE') {
				$params++;
			}
		}
		if ($params >= 5) {
			for ($i = $h; $i <= $k; $i++) {
				$tokens[$i]->tokenMessage .= "This function has too many params. ";
			}
		}
	}

}
